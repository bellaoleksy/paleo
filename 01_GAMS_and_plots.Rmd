---
title: "01_GAMS_and_plots"
author: "Bella Oleksy"
date: "4/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Document history
I created this R markdown file on April 12, 2019 after submitting the manuscript to Ecosystems on April 1, 2019.
Based off of "SkyLochMaster_R_NEWANDIMPROVED.R" which was created November 29, 2018 after correcting GAMs and visuals with advice from Jared Wolfe

LVDC3_Master_RawR_170329.csv is the version I used for a long time.
Now switching to LVDC3_Master_RawR_180208.csv ... only difference is
that I added a column for date, which has the interpolation from Jack Cornett's original spreadsheet
very approximate, still waiting on dates from Peter.

I didn't transfer over a lot of the exploratory stuff, like the PCAs, just so you know. 

# Load 
### Packages
```{r }

# devtools::install_github("kassambara/ggpubr", force=TRUE)
library(ggpubr)
library(plyr)
library(lattice)
library(car)
library(lsmeans)
library(grid) #for function unit() in ggplot2
library(gtable) #for adding subtitle in ggplot2
library(dplyr)
library(tidyr)

library(scales) # to add percentages to plots and pretty_breaks()
library(gridExtra) #for arranging graphs side by side w ftn grid.arrange()
library(skimr)#Summary statistics
library(reshape2)



#load packages necessary for GAMS
library("mgcv")
library("scam")
library("cowplot")
library("grid")                         # for unit.pmax(), unit.list()
library("schoenberg")
library("tidyr")
library("nlme")
```

### Data
```{r}
master_core_wide <- read.csv("data/output/master_core_wide.csv")
master_core_long <- read.csv("data/output/master_core_long.csv")
loch_wide <- read.csv("data/output/loch_wide.csv")
sky_wide <- read.csv(file="data/output/sky_wide")
zscores_master <- read.csv("data/raw/sky_loch_zscores.csv")
diatom_full<- read.csv("data/output/diatom_full.csv")
```

##Plot themes
```{r}
library(ggthemes)
library(ggplot2)
library(ggpmisc)
library(ggpubr)
#Customize theme 
#http://joeystanley.com/blog/custom-themes-in-ggplot2 
theme_paleo <- function () { 
  theme_base(base_size=12, base_family="Helvetica") %+replace% 
    theme(
      panel.background  = element_blank(),
      plot.background = element_rect(fill="white", colour=NA),
      plot.title=element_text(face="plain",hjust=0),
      plot.subtitle = element_text(color="dimgrey", hjust=0, size=10),
      axis.title=element_text(face="plain"),
      panel.grid.minor=element_blank()
    )
}
# , panel.grid.major=element_line(color="lightgrey")
theme_set(theme_paleo())  # pre-set the bw theme
```

#EXPLORATORY

###DNR - Loch vs. Sky z-scores 
```{r}
#####################################
# Archived exploratory analyses.#####
# Keep but do not run.###############
#####################################

sky_z <- zscores_master %>%
  select(sky_z,depth_sky) %>%
  filter(sky_z < 2)

loch_z <- zscores_master %>%
  select(loch_z,depth_loch) %>%
  filter(loch_z < 2)


sky_lm <- lm(sky_z ~ depth_sky, data=sky_z)
summary(sky_lm)
(sky_lm$coefficients)

loch_lm <- lm(loch_z ~ depth_loch, data=loch_z)
summary(loch_lm)
print(loch_lm$coefficients)



sky_lm_change=sky_z[,1] #Pull out just zscore column

library(trend)
pettitt.test(sky_lm_change) #Changepoint at 30 datapoint; p-value > 0.0001 (marginally significant) 
sky_z[13,]
#         sky_z depth_sky
# 13 -0.7541103       3.5

loch_lm_change=loch_z[,1] #z-score column
pettitt.test(loch_lm_change)
loch_z[12,]
#        loch_z depth_loch
# 12 -0.5672333       3.25


##Investigating significant changepoint

sky_low=subset(sky_z, depth_sky<3.5)
loch_low=subset(loch_z, depth_loch<3.5)

# Regressions

skymod_low=lm(sky_z~depth_sky, data=sky_low)
lochmod_low=lm(loch_z~depth_loch, data=loch_low)


```

#ANALYSES - GAMS


## Derivatives functions
```{r}
Deriv <- function(mod, n = 200, eps = 1e-7, newdata, term) {
    if(inherits(mod, "gamm"))
        mod <- mod$gam
    m.terms <- attr(terms(mod), "term.labels")
    if(missing(newdata)) {
        newD <- sapply(model.frame(mod)[, m.terms, drop = FALSE],
                       function(x) seq(min(x), max(x), length = n))
        names(newD) <- m.terms
    } else {
        newD <- newdata
    }
    X0 <- predict(mod, data.frame(newD), type = "lpmatrix")
    newD <- newD + eps
    X1 <- predict(mod, data.frame(newD), type = "lpmatrix")
    Xp <- (X1 - X0) / eps
    Xp.r <- NROW(Xp)
    Xp.c <- NCOL(Xp)
    ## dims of bs
    bs.dims <- sapply(mod$smooth, "[[", "bs.dim") - 1
    ## number of smooth terms
    t.labs <- attr(mod$terms, "term.labels")
    ## match the term with the the terms in the model
    if(!missing(term)) {
        want <- grep(term, t.labs)
        if(!identical(length(want), length(term)))
            stop("One or more 'term's not found in model!")
        t.labs <- t.labs[want]
    }
    nt <- length(t.labs)
    ## list to hold the derivatives
    lD <- vector(mode = "list", length = nt)
    names(lD) <- t.labs
    for(i in seq_len(nt)) {
        Xi <- Xp * 0
        want <- grep(t.labs[i], colnames(X1))
        Xi[, want] <- Xp[, want]
        df <- Xi %*% coef(mod)
        df.sd <- rowSums(Xi %*% mod$Vp * Xi)^.5
        lD[[i]] <- list(deriv = df, se.deriv = df.sd)
    }
    class(lD) <- "Deriv"
    lD$gamModel <- mod
    lD$eps <- eps
    lD$eval <- newD - eps
    lD ##return
}

confint.Deriv <- function(object, term, alpha = 0.05, ...) {
    l <- length(object) - 3
    term.labs <- names(object[seq_len(l)])
    if(missing(term)) {
        term <- term.labs
    } else { ## how many attempts to get this right!?!?
        ##term <- match(term, term.labs)
        ##term <- term[match(term, term.labs)]
        term <- term.labs[match(term, term.labs)]
    }
    if(any(miss <- is.na(term)))
        stop(paste("'term'", term[miss], "not a valid model term."))
    res <- vector(mode = "list", length = length(term))
    names(res) <- term
    residual.df <- df.residual(object$gamModel)
    tVal <- qt(1 - (alpha/2), residual.df)
    ##for(i in term.labs[term]) {
    for(i in term) {
        upr <- object[[i]]$deriv + tVal * object[[i]]$se.deriv
        lwr <- object[[i]]$deriv - tVal * object[[i]]$se.deriv
        res[[i]] <- list(upper = drop(upr), lower = drop(lwr))
    }
    res$alpha = alpha
    res
}

signifD <- function(x, d, upper, lower, eval = 0) {
    miss <- upper > eval & lower < eval
    incr <- decr <- x
    want <- d > eval
    incr[!want | miss] <- NA
    want <- d < eval
    decr[!want | miss] <- NA
    list(incr = incr, decr = decr)
}

plot.Deriv <- function(x, alpha = 0.05, polygon = TRUE,
                       sizer = FALSE, term,
                       eval = 0, lwd = 3,
                       col = "lightgrey", border = col,
                       ylab, xlab, main, ...) {
    l <- length(x) - 3
    ## get terms and check specified (if any) are in model
    term.labs <- names(x[seq_len(l)])
    if(missing(term)) {
        term <- term.labs
    } else {
        term <- term.labs[match(term, term.labs)]
    }
    if(any(miss <- is.na(term)))
        stop(paste("'term'", term[miss], "not a valid model term."))
    if(all(miss))
        stop("All terms in 'term' not found in model.")
    l <- sum(!miss)
    nplt <- n2mfrow(l)
    tVal <- qt(1 - (alpha/2), df.residual(x$gamModel))
    if(missing(ylab))
        ylab <- expression(italic(hat(f)*"'"*(x)))
    if(missing(xlab)) {
        xlab <- attr(terms(x$gamModel), "term.labels")
        names(xlab) <- xlab
    }
    if (missing(main)) {
        main <- term
        names(main) <- term
    }
    ## compute confidence interval
    CI <- confint(x, term = term)
    ## plots
    layout(matrix(seq_len(l), nrow = nplt[1], ncol = nplt[2]))
    for(i in term) {
        upr <- CI[[i]]$upper
        lwr <- CI[[i]]$lower
        ylim <- range(upr, lwr)
        plot(x$eval[,i], x[[i]]$deriv, type = "n",
             ylim = ylim, ylab = ylab, xlab = xlab[i], main = main[i], ...)
        if(isTRUE(polygon)) {
            polygon(c(x$eval[,i], rev(x$eval[,i])),
                    c(upr, rev(lwr)), col = col, border = border)
        } else {
            lines(x$eval[,i], upr, lty = "dashed")
            lines(x$eval[,i], lwr, lty = "dashed")
        }
        abline(h = 0, ...)
        if(isTRUE(sizer)) {
            lines(x$eval[,i], x[[i]]$deriv, lwd = 1)
            S <- signifD(x[[i]]$deriv, x[[i]]$deriv, upr, lwr,
                         eval = eval)
            lines(x$eval[,i], S$incr, lwd = lwd, col = "blue")
            lines(x$eval[,i], S$decr, lwd = lwd, col = "red")
        } else {
            lines(x$eval[,i], x[[i]]$deriv, lwd = 2)
        }
    }
    layout(1)
    invisible(x)
}
```


### GEOCHEMICAL 

##### d15N GAMs Sky
```{r}
# **Geochemical: d15N GAMs Sky --------------------------------------------

###########Fitting GAMs for Sky Pond del15N

### I added Family Gamma here for how errors should respond
mod_del15N_S <- gamm(del15N ~ s(age_sky, k = 22),  data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
del15NPhi_S <- intervals(mod_del15N_S$lme, which = "var-cov")$corStruct
del15NPhi_S

## The CAR(1) process plotted in Figure 11 Simpson of the manuscript was prepared using:
S <- seq(0, 50, length = 100)
car1 <- setNames(as.data.frame(t(outer(del15NPhi_S, S, FUN = `^`)[1, , ])),
c("Lower","Correlation","Upper"))
car1 <- transform(car1, S = S)
car1Plt <- ggplot(car1, aes(x = S, y = Correlation)) +
geom_ribbon(aes(ymax = Upper, ymin = Lower),
fill = "black", alpha = 0.2) +
geom_line() +
ylab(expression(italic(c) * (list(h, varphi)))) +
xlab(expression(h ~ (years)))
car1Plt
#The exponential decline in correlation with increasing separation is evident here; 
#However, it isn't until samples are ~30 years apart or so that there is little estimated dependence between samples


## summary object for use in document
del15NSumm_S <- summary(mod_del15N_S$gam)
del15NSumm_S #Gives you the P values, degrees of freedom...
print.summary.gam(del15NSumm_S)

### Check diagnostics. You might need to adjust model
gam.check(mod_del15N_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
del15NYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
del15NYear_S <- cbind(del15NYear_S, data.frame(predict(mod_del15N_S$gam, del15NYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
del15NYear_S <- transform(del15NYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
del15NYear_S$lake_ID <- 'SkyPond'

## Plot fitted trends
del15N_fitted_S <- ggplot(del15NYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = del15N), inherit.aes = FALSE) +
  geom_line() 
del15N_fitted_S


############
############
#First derivatives
############
############
# install.packages("devtools")
# devtools::install_github("gavinsimpson/gratia")
# library("gratia")
# set.seed(1) # set the random seed to make this reproducible
# nsim <- 20 # how many simulations to draw
# ## do the simulations
# sims <- simulate(mod_del15N_S, nsim = nsim, newdata = del15NYear_S, unconditional = TRUE)
# 
# ## rearrange the output into a long/tidy format
# colnames(sims) <- paste0("sim", seq_len(nsim))
# sims <- setNames(stack(as.data.frame(sims)), c("simulated", "run"))
# sims <- transform(sims, Year = rep(del15NYear_S$age_sky, nsim),
#                   simulated = simulated)
# 
# ## Plot simulated trends
# skySim.plt <- ggplot(del15NYear_S, aes(x = age_sky, y = fit)) +
# geom_line(data = sims,
# mapping = aes(y = simulated, x = Year, group = run),
# colour = "grey80") +
# geom_line(lwd = 1) +
# labs(y = "d15N", x = "Year CE")
# skySim.plt
# 
# 
sky.d <- fderiv(mod_del15N_S, del15NYear_S = age_sky, n = 20)
sky.sint <- with(del15NYear_S,
                 cbind(confint(sky.d, nsim = nsim,
                               type = "simultaneous"),
                       Year = age_sky))
sky_deriv_plt <- ggplot(sky.sint, aes(x = Year, y = est)) +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2,
fill = "black") +
geom_line() +
labs(x = "Year CE", y = "First derivative")
sky_deriv_plt

###TRY A DIFFERENT WAY $$

library(gratia)

fd_inc = confint(fderiv(mod_del15N_S))
fd_inc

```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_del15N_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(del15NYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(del15NYear_S, range(upper, lower, fit))
ylab <- expression(paste(delta^{15}, "N (‰)"))

plot(fit ~ age_sky, data = del15NYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = del15NYear_S)
lines(upper ~ age_sky, data = del15NYear_S, lty = "dashed")
lines(lower ~ age_sky, data = del15NYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = del15NYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = del15NYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), del15NYear_S$age_sky) %>%
  rename(value=unlist.m2.dsig.decr.,
         age_sky=del15NYear_S.age_sky)
#### NO evidence of it decreasing AFTER 2001!!!
str(decr)


```




#### d15N GAMs Loch
```{r}
# **Geochemical: d15N GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch del15N


mod_del15N_L <- gamm(del15N ~ s(age_sky, k = 10), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")
#best so far is 2. Maybe a linear model is better...?




## estimate of phi and confidence interval
del15NPhi_L <- intervals(mod_del15N_L$lme, which = "var-cov")$corStruct
del15NPhi_L

## summary object for use in document
del15NSumm_L <- summary(mod_del15N_L$gam)
del15NSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_del15N_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
del15NYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
del15NYear_L <- cbind(del15NYear_L, data.frame(predict(mod_del15N_L$gam, del15NYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
del15NYear_L <- transform(del15NYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
del15NYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
del15N_fitted_L <- ggplot(del15NYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = del15N), inherit.aes = FALSE) +
  geom_line() 
del15N_fitted_L
```

###### plot d15N
```{r}
#Plot in MS form
del15N_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="del15N")

del15N_CI <- bind_rows(del15NYear_L, del15NYear_S)


#from periods of change chunk
del15NYear_S_sig_decr <- del15NYear_S %>%
  filter(age_sky >= 1895 & age_sky <= 2000)

del15N_plot<-ggplot(del15N_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=del15N_long, mapping=aes(x=age_sky, y=response), size=2.5, alpha=0.7) +
  geom_line(size=1)+
      # geom_line(data=del15NYear_S_sig_decr, mapping=aes(x=age_sky, y=fit), size=2, color="black")+ ## Adding period of change line
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,7))+
  scale_y_continuous(breaks=seq(0, 7, 1))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y=expression(paste(delta^{15}, "N (‰)")))+
  scale_color_manual(
    name="\n",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="\n",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())
del15N_plot
#Yay it works!

```

#### d13C GAMs Sky
```{r}
# **Geochemical: d13C GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond d13C

### I added Family Gamma here for how errors should respond
mod_del13C_S <- gamm(del13C ~ s(age_sky, k = 9),  data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
del13CPhi_S <- intervals(mod_del13C_S$lme, which = "var-cov")$corStruct
del13CPhi_S

## summary object for use in document
del13CSumm_S <- summary(mod_del13C_S$gam)
del13CSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_del13C_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
del13CYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
del13CYear_S <- cbind(del13CYear_S, data.frame(predict(mod_del13C_S$gam, del13CYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
del13CYear_S <- transform(del13CYear_S,
                          upper = fit + (2 * se.fit),
                          lower = fit - (2 * se.fit))
del13CYear_S$lake_ID <- 'SkyPond'



## Plot simulated trends
del13C_fitted_S <- 
  ggplot(del13CYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = del13C), inherit.aes = FALSE) +
  geom_line() 

del13C_fitted_S


```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_del13C_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(del13CYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(del13CYear_S, range(upper, lower, fit))
ylab <- expression(paste(delta^{13}, "C (‰)"))

plot(fit ~ age_sky, data = del13CYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = del13CYear_S)
lines(upper ~ age_sky, data = del13CYear_S, lty = "dashed")
lines(lower ~ age_sky, data = del13CYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = del13CYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = del13CYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), del13CYear_S$age_sky) %>%
  rename(value=unlist.m2.dsig.decr.,
         age_sky=del13CYear_S.age_sky)

```


#### d13C GAMs Loch
```{r}
# **Geochemical: d13C GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch d13C

### I added Family Gamma here for how errors should respond

mod_del13C_L <- gamm(del13C ~ s(age_sky, k = 2), data = loch_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
del13CPhi_L <- intervals(mod_del13C_L$lme, which = "var-cov")$corStruct
del13CPhi_L

## summary object for use in document
del13CSumm_L <- summary(mod_del13C_L$gam)
del13CSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_del13C_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
del13CYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
del13CYear_L <- cbind(del13CYear_L, data.frame(predict(mod_del13C_L$gam, del13CYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
del13CYear_L <- transform(del13CYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
del13CYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
del13C_fitted_L <- ggplot(del13CYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = del13C), inherit.aes = FALSE) +
  geom_line() 
del13C_fitted_L
```

###### plot d13C
```{r}
#MS Plot
del13C_long <- master_core_long %>%
  filter(proxy_ID=="del13C")

del13C_CI <- bind_rows(del13CYear_L, del13CYear_S)

#from periods of change chunk
del13CYear_S_sig_decr <- del13CYear_S %>%
  filter(age_sky >= 1926)
  

del13C_plot<-ggplot(del13C_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=-30, ymax=-20, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1946, xmax=2001, ymin=-30, ymax=Inf, alpha=0.4, fill="grey50") +
  geom_point(data=del13C_long, mapping=aes(x=age_sky, y=response), size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
    # geom_line(data=del13CYear_S_sig_decr, mapping=aes(x=age_sky, y=fit), size=2, color="black")+ ## Adding period of change line
  # coord_cartesian(ylim=seq(-28,-22))+
  labs(y=expression(paste(delta^{13}, "C (‰)")), x="")+
  scale_y_continuous(breaks=seq(-28,-22, 1))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
    scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  # scale_fill_manual(
  #   name="",
  #   breaks=c("SkyPond","TheLoch"),
  #   labels=c("Sky Pond","The Loch"),
  #   values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom", legend.text = element_text(size=12))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))

del13C_plot
```

#### %C GAMs Sky
```{r}

# **Geochemical: %C GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond %C

### I added Family Gamma here for how errors should respond
mod_percC_S <- gamm(percC ~ s(age_sky, k = 8),  data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
percCPhi_S <- intervals(mod_percC_S$lme, which = "var-cov")$corStruct
percCPhi_S

## summary object for use in document
percCSumm_S <- summary(mod_percC_S$gam)
percCSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_percC_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
percCYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
percCYear_S <- cbind(percCYear_S, data.frame(predict(mod_percC_S$gam, percCYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
percCYear_S <- transform(percCYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
percCYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
percC_fitted_S <- ggplot(percCYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = percC), inherit.aes = FALSE) +
  geom_line() 
percC_fitted_S
```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_percC_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(percCYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(percCYear_S, range(upper, lower, fit))
ylab <- "% C"

plot(fit ~ age_sky, data = percCYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = percCYear_S)
lines(upper ~ age_sky, data = percCYear_S, lty = "dashed")
lines(lower ~ age_sky, data = percCYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = percCYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = percCYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), percCYear_S$age_sky) 
incr<-data.frame(unlist(m2.dsig$incr), percCYear_S$age_sky) 


```





#### %C GAMs Loch
```{r}
# **Geochemical: %C GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch %C

### I added Family Gamma here for how errors should respond
#6
mod_percC_L <- gamm(percC ~ s(age_sky, k = 6), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
percCPhi_L <- intervals(mod_percC_L$lme, which = "var-cov")$corStruct
percCPhi_L

## summary object for use in document
percCSumm_L <- summary(mod_percC_L$gam)
percCSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_percC_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
percCYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
percCYear_L <- cbind(percCYear_L, data.frame(predict(mod_percC_L$gam, percCYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
percCYear_L <- transform(percCYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
percCYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
percC_fitted_L <- ggplot(percCYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = percC), inherit.aes = FALSE) +
  geom_line() 
percC_fitted_L
```

###### plot %C
```{r}
#MS Plot
percC_long <- master_core_long %>%
  filter(proxy_ID=="percC")

percC_CI <- bind_rows(percCYear_L, percCYear_S)


percC_plot<-ggplot(percC_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=percC_long, mapping=aes(x=age_sky, y=response),   size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,10))+
  scale_y_continuous(breaks=seq(0, 10, 2))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="C  (% dry mass)")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
    scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  # scale_fill_manual(
  #   name="",
  #   breaks=c("SkyPond","TheLoch"),
  #   labels=c("Sky Pond","The Loch"),
  #   values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())

percC_plot
```

#### %N GAMs Sky
```{r}
# **Geochemical: %N GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond %N

### I added Family Gamma here for how errors should respond
mod_percN_S <- gamm(percN ~ s(age_sky, k = 6),  data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
percNPhi_S <- intervals(mod_percN_S$lme, which = "var-cov")$corStruct
percNPhi_S

## summary object for use in document
percNSumm_S <- summary(mod_percN_S$gam)
percNSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_percN_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
percNYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
percNYear_S <- cbind(percNYear_S, data.frame(predict(mod_percN_S$gam, percNYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
percNYear_S <- transform(percNYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
percNYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
percN_fitted_S <- ggplot(percNYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = percN), inherit.aes = FALSE) +
  geom_line() 
percN_fitted_S
```
###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_percN_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(percNYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(percNYear_S, range(upper, lower, fit))
ylab <- "% N"

plot(fit ~ age_sky, data = percNYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = percNYear_S)
lines(upper ~ age_sky, data = percNYear_S, lty = "dashed")
lines(lower ~ age_sky, data = percNYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = percNYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = percNYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), percNYear_S$age_sky) 
incr<-data.frame(unlist(m2.dsig$incr), percNYear_S$age_sky) 

```


#### %N GAMs Loch
```{r}
# **Geochemical: %N GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch %N

### I added Family Gamma here for how errors should respond

mod_percN_L <- gamm(percN ~ s(age_sky, k = 10), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
percNPhi_L <- intervals(mod_percN_L$lme, which = "var-cov")$corStruct
percNPhi_L

## summary object for use in document
percNSumm_L <- summary(mod_percN_L$gam)
percNSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_percN_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
percNYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
percNYear_L <- cbind(percNYear_L, data.frame(predict(mod_percN_L$gam, percNYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
percNYear_L <- transform(percNYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
percNYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
percN_fitted_L <- ggplot(percNYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = percN), inherit.aes = FALSE) +
  geom_line() 
percN_fitted_L
```

###### plot %N
```{r}

#MS Plot
percN_long <- master_core_long %>%
  filter(proxy_ID=="percN")

percN_CI <- bind_rows(percNYear_L, percNYear_S)


percN_plot<-ggplot(percN_CI,aes(x=age_sky,y=fit,  color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=percN_long, mapping=aes(x=age_sky, y=response),  size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,1))+
  scale_y_continuous(breaks=seq(0, 1, 0.2))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="N (% dry mass)")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())
percN_plot
```

#### C:N GAMs Sky
```{r}

# **Geochemical: C:N GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond C:N

### I added Family Gamma here for how errors should respond
mod_CN_S <- gamm(CN ~ s(age_sky, k = 15),  data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
CNPhi_S <- intervals(mod_CN_S$lme, which = "var-cov")$corStruct
CNPhi_S

## summary object for use in document
CNSumm_S <- summary(mod_CN_S$gam)
CNSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_CN_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
CNYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
CNYear_S <- cbind(CNYear_S, data.frame(predict(mod_CN_S$gam, CNYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
CNYear_S <- transform(CNYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
CNYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
CN_fitted_S <- ggplot(CNYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = CN), inherit.aes = FALSE) +
  geom_line() 
CN_fitted_S
```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_CN_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(CNYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(CNYear_S, range(upper, lower, fit))
ylab <- "C:N"

plot(fit ~ age_sky, data = CNYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = CNYear_S)
lines(upper ~ age_sky, data = CNYear_S, lty = "dashed")
lines(lower ~ age_sky, data = CNYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = CNYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = CNYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), CNYear_S$age_sky) 
incr<-data.frame(unlist(m2.dsig$incr), CNYear_S$age_sky) 


```





#### C:N GAMs Loch
```{r}
# **Geochemical: C:N GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch C:N

### I added Family Gamma here for how errors should respond

mod_CN_L <- gamm(CN ~ s(age_sky, k = 15), data = loch_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
CNPhi_L <- intervals(mod_CN_L$lme, which = "var-cov")$corStruct
CNPhi_L

## summary object for use in document
CNSumm_L <- summary(mod_CN_L$gam)
CNSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_CN_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
CNYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
CNYear_L <- cbind(CNYear_L, data.frame(predict(mod_CN_L$gam, CNYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
CNYear_L <- transform(CNYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
CNYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
CN_fitted_L <- ggplot(CNYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = CN), inherit.aes = FALSE) +
  geom_line() 
CN_fitted_L
```

###### plot C:N
```{r}
#MS Plot
CN_long <- master_core_long %>%
  filter(proxy_ID=="CN")

CN_CI <- bind_rows(CNYear_L, CNYear_S)


CN_plot<-ggplot(CN_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=CN_long, mapping=aes(x=age_sky, y=response), size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,20))+
  scale_y_continuous(breaks=seq(0, 20, 4))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  labs(y="C:N ratio", x="Year")+
  # theme(legend.position="bottom", legend.text = element_text(size=12))+
  # guides(shape = guide_legend(override.aes = list(size=10)),
  #        color = guide_legend(override.aes = list(linetype = 0)))
  theme(legend.position="bottom", legend.text = element_text(size=12))

CN_plot
```

### TOTAL PRODUCTION

#### Pheo a GAMs Sky
```{r}
# TOTAL PRODUCTION~~~~~~~~~~~~~~~~~~~~~ --------------------------------------------

# **TotProd: Pheo a GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Lutein

### I added Family Gamma here for how errors should respond
mod_pheoa_S <- gamm(pheo_a ~ s(age_sky, k =5),
                    family=Gamma(link="log"), data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky),
                    method = "REML")

## estimate of phi and confidence interval
pheoaPhi_S <- intervals(mod_pheoa_S$lme, which = "var-cov")$corStruct
pheoaPhi_S

## summary object for use in document
pheoaSumm_S <- summary(mod_pheoa_S$gam)
pheoaSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_pheoa_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
pheoaYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
pheoaYear_S <- cbind(pheoaYear_S, data.frame(predict(mod_pheoa_S$gam, pheoaYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
pheoaYear_S <- transform(pheoaYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
pheoaYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
pheoa_fitted_S <- ggplot(pheoaYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = pheo_a), inherit.aes = FALSE) +
  geom_line() 
pheoa_fitted_S
```



###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_pheoa_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(pheoaYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(pheoaYear_S, range(upper, lower, fit))
ylab <- expression(paste("Pheophytin ",italic("a")))

plot(fit ~ age_sky, data = pheoaYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = pheoaYear_S)
lines(upper ~ age_sky, data = pheoaYear_S, lty = "dashed")
lines(lower ~ age_sky, data = pheoaYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = pheoaYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = pheoaYear_S, col = "red", lwd = 3)


incr<-data.frame(unlist(m2.dsig$incr), luteinYear_S$age_sky)
```




#### Pheo a GAMs Loch
```{r}
# **TotProd: Pheo a GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch Lutein

### I added Family Gamma here for how errors should respond

mod_pheoa_L <- gamm(pheo_a ~ s(age_sky, k = 8), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")
#best so far is 2. Maybe a linear model is better...?


## estimate of phi and confidence interval
pheoaPhi_L <- intervals(mod_pheoa_L$lme, which = "var-cov")$corStruct
pheoaPhi_L

## summary object for use in document
pheoaSumm_L <- summary(mod_pheoa_L$gam)
pheoaSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_pheoa_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
pheoaYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
pheoaYear_L <- cbind(pheoaYear_L, data.frame(predict(mod_pheoa_L$gam, pheoaYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
pheoaYear_L <- transform(pheoaYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
pheoaYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
pheoa_fitted_L <- ggplot(pheoaYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = pheo_a), inherit.aes = FALSE) +
  geom_line() 
pheoa_fitted_L

```

###### plot pheo a
```{r}
#Plot in MS form
pheoa_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="pheo_a")

pheoa_CI <- bind_rows(pheoaYear_L, pheoaYear_S)


pheoa_plot<-ggplot(pheoa_CI,aes(x=age_sky,y=fit,  color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1942, xmax=2001, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=pheoa_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,1500))+
  scale_y_continuous(breaks=seq(0,1500,300))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(x="\nYear",y="", title=c(expression(paste("Pheophytin ",italic("a")))),
       subtitle="Total algal biomass")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
pheoa_plot

```

#### Bcar GAMs Sky
```{r}
# **TotProd: Bcar GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond Pheo B

### I added Family Gamma here for how errors should respond
mod_betaC_S <- gamm(b_car ~ s(age_sky, k = 4), family=Gamma(link="log"), data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky),
                    method = "REML")

## estimate of phi and confidence interval
betaCPhi_S <- intervals(mod_betaC_S$lme, which = "var-cov")$corStruct
betaCPhi_S

## summary object for use in document
betaCSumm_S <- summary(mod_betaC_S$gam)
betaCSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_betaC_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
betaCYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
betaCYear_S <- cbind(betaCYear_S, data.frame(predict(mod_betaC_S$gam, betaCYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
betaCYear_S <- transform(betaCYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
betaCYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
betaC_fitted_S <- ggplot(betaCYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = b_car), inherit.aes = FALSE) +
  geom_line() 
betaC_fitted_S
```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_betaC_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(betaCYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(betaCYear_S, range(upper, lower, fit))
ylab <-expression(paste(beta,"-carotene"))

plot(fit ~ age_sky, data = betaCYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = betaCYear_S)
lines(upper ~ age_sky, data = betaCYear_S, lty = "dashed")
lines(lower ~ age_sky, data = betaCYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = betaCYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = betaCYear_S, col = "red", lwd = 3)

#Steadily increasing...

```



#### Bcar GAMs Loch
```{r}
# **TotProd: Bcar GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch betaC

### I added Family Gamma here for how errors should respond

mod_betaC_L <- gamm(b_car ~ s(age_sky, k = 4), family=Gamma(link="log"), data = loch_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")
#best so far is 2. Maybe a linear model is better...?


## estimate of phi and confidence interval
betaCPhi_L <- intervals(mod_betaC_L$lme, which = "var-cov")$corStruct
betaCPhi_L

## summary object for use in document
betaCSumm_L <- summary(mod_betaC_L$gam)
betaCSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_betaC_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
betaCYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
betaCYear_L <- cbind(betaCYear_L, data.frame(predict(mod_betaC_L$gam, betaCYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
betaCYear_L <- transform(betaCYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
betaCYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
betaC_fitted_L <- ggplot(betaCYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = b_car), inherit.aes = FALSE) +
  geom_line() 
betaC_fitted_L
```

###### plot Bcar
```{r}
#MS Plot
bcar_long <- master_core_long %>%
  filter(proxy_ID=="b_car")

bcar_CI <- bind_rows(betaCYear_L, betaCYear_S)


bcar_plot<-ggplot(bcar_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=bcar_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  labs(y="", x="", title=c(expression(paste(beta,"-carotene"))),
       subtitle="Total algal biomass")+
  coord_cartesian(ylim=c(0,600))+
  scale_y_continuous(breaks=seq(0, 600,100))+ 
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
bcar_plot
```

#### PI GAMs Sky
```{r}

# **TotProd: PI GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond Pheo B

### I added Family Gamma here for how errors should respond
mod_PI_S <- gamm(PI ~ s(age_sky, k = 5), family=Gamma(link="log"), data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
PIPhi_S <- intervals(mod_PI_S$lme, which = "var-cov")$corStruct
PIPhi_S

## summary object for use in document
PISumm_S <- summary(mod_PI_S$gam)
PISumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_PI_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
PIYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
PIYear_S <- cbind(PIYear_S, data.frame(predict(mod_PI_S$gam, PIYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
PIYear_S <- transform(PIYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
PIYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
PI_fitted_S <- ggplot(PIYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = PI), inherit.aes = FALSE) +
  geom_line() 
PI_fitted_S
```

#### PI GAMs Loch
```{r}
# **TotProd: PI GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch PI

### I added Family Gamma here for how errors should respond

mod_PI_L <- gamm(PI ~ s(age_sky, k = 10), family=Gamma(link="log"), data = loch_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
PIPhi_L <- intervals(mod_PI_L$lme, which = "fixed")$corStruct
PIPhi_L

## summary object for use in document
PISumm_L <- summary(mod_PI_L$gam)
PISumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_PI_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
PIYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
PIYear_L <- cbind(PIYear_L, data.frame(predict(mod_PI_L$gam, PIYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
PIYear_L <- transform(PIYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
PIYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
PI_fitted_L <- ggplot(PIYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = PI), inherit.aes = FALSE) +
  geom_line() 
PI_fitted_L
```

###### plot PI
```{r}
#MS Plot
PI_long <- master_core_long %>%
  filter(proxy_ID=="PI")

PI_CI <- bind_rows(PIYear_L, PIYear_S)


PI_plot<-ggplot(PI_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=PI_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  labs(y="Preservation index", x="Year")+
  coord_cartesian(ylim=c(0,2.0))+
  scale_y_continuous(breaks=pretty_breaks(n=6))+ #breaks=seq(0, 1.6,0.4)
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom", legend.text = element_text(size=12))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))


PI_plot
ggsave("figures/MS/FigureS1_PI.png", width=8, height=6,units="in")


```

### GREEN ALGAE

#### Lutein GAMs Sky
```{r}

# **GREENS: Lutein GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Lutein

### I added Family Gamma here for how errors should respond
mod_lutein_S <- gamm(lutein ~ s(age_sky, k = 7), family=Gamma(link="log"), data = sky_wide,
                   correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
luteinPhi_S <- intervals(mod_lutein_S$lme, which = "var-cov")$corStruct
luteinPhi_S

## summary object for use in document
luteinSumm_S <- summary(mod_lutein_S$gam)
luteinSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_lutein_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
luteinYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
luteinYear_S <- cbind(luteinYear_S, data.frame(predict(mod_lutein_S$gam, luteinYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
luteinYear_S <- transform(luteinYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
luteinYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
lutein_fitted_S <- ggplot(luteinYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = lutein), inherit.aes = FALSE) +
  geom_line() 
lutein_fitted_S
```



###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_lutein_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(luteinYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(luteinYear_S, range(upper, lower, fit))
ylab <- "lutein"

plot(fit ~ age_sky, data = luteinYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = luteinYear_S)
lines(upper ~ age_sky, data = luteinYear_S, lty = "dashed")
lines(lower ~ age_sky, data = luteinYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = luteinYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = luteinYear_S, col = "red", lwd = 3)


incr<-data.frame(unlist(m2.dsig$incr), luteinYear_S$age_sky)
#### NO evidence of it increasing after 1973

```


####Lutein GAMs Loch
```{r}
# **GREENS: Lutein GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch Lutein

### I added Family Gamma here for how errors should respond
#
mod_lutein_L <- gamm(lutein ~ s(age_sky, k = 3), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")
#best so far is 2. Maybe a linear model is better...?


## estimate of phi and confidence interval
luteinPhi_L <- intervals(mod_lutein_L$lme, which = "var-cov")$corStruct
luteinPhi_L

## summary object for use in document
luteinSumm_L <- summary(mod_lutein_L$gam)
luteinSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_lutein_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
luteinYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
luteinYear_L <- cbind(luteinYear_L, data.frame(predict(mod_lutein_L$gam, luteinYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
luteinYear_L <- transform(luteinYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
luteinYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
lutein_fitted_L <- ggplot(luteinYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = lutein), inherit.aes = FALSE) +
  geom_line() 
lutein_fitted_L

```

###### plot lutein
```{r}
#Plot in MS form
lutein_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="lutein")

lutein_CI <- bind_rows(luteinYear_L, luteinYear_S)


lutein_plot<-ggplot(lutein_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1924, xmax=1956, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=lutein_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  labs(x="\nYear",y="", title=c(expression(paste("Lutein & Zeaxanthin"))),
       subtitle="Chlorophytes, cyanobacteria")+ 
  scale_y_continuous(limits=c(0, 500), breaks=seq(0, 500, 100))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        plot.subtitle = element_text(color="dimgrey", hjust=0, size=10))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
lutein_plot
#Yay it works!
```


#### Pheob GAMs Sky
```{r}
# **GREENS: Pheob GAMs Sky --------------------------------------------



###########Fitting GAMs for Sky Pond Pheo B

### I added Family Gamma here for how errors should respond
mod_pheob_S <- gamm(phaeo_b ~ s(age_sky, k = 7), family=Gamma(link="log"), data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky),
                    method = "REML")

## estimate of phi and confidence interval
pheobPhi_S <- intervals(mod_pheob_S$lme, which = "var-cov")$corStruct
pheobPhi_S

## summary object for use in document
pheobSumm_S <- summary(mod_pheob_S$gam)
pheobSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_pheob_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
pheobYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
pheobYear_S <- cbind(pheobYear_S, data.frame(predict(mod_pheob_S$gam, pheobYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
pheobYear_S <- transform(pheobYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
pheobYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
pheob_fitted_S <- ggplot(pheobYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = phaeo_b), inherit.aes = FALSE) +
  geom_line() 
pheob_fitted_S
```


###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_pheob_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(pheobYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(pheobYear_S, range(upper, lower, fit))
ylab <- "pheo b"

plot(fit ~ age_sky, data = pheobYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = pheobYear_S)
lines(upper ~ age_sky, data = pheobYear_S, lty = "dashed")
lines(lower ~ age_sky, data = pheobYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = pheobYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = pheobYear_S, col = "red", lwd = 3)


incr<-data.frame(unlist(m2.dsig$incr), luteinYear_S$age_sky)
#### NO evidence of it increasing after 1973

```



#### Pheob GAMs Loch
```{r}
# **GREENS: Pheob GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch pheob

### I added Family Gamma here for how errors should respond

mod_pheob_L <- gamm(phaeo_b ~ s(age_sky, k = 8), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")
#best so far is 2. Maybe a linear model is better...?


## estimate of phi and confidence interval
pheobPhi_L <- intervals(mod_pheob_L$lme, which = "var-cov")$corStruct
pheobPhi_L

## summary object for use in document
pheobSumm_L <- summary(mod_pheob_L$gam)
pheobSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_pheob_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
pheobYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
pheobYear_L <- cbind(pheobYear_L, data.frame(predict(mod_pheob_L$gam, pheobYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
pheobYear_L <- transform(pheobYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
pheobYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
pheob_fitted_L <- ggplot(pheobYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = phaeo_b), inherit.aes = FALSE) +
  geom_line() 
pheob_fitted_L

#MS Plot
pheob_long <- master_core_long %>%
  filter(proxy_ID=="phaeo_b")

pheob_CI <- bind_rows(pheobYear_L, pheobYear_S)
```

###### plot pheo b
```{r}
pheob_plot<-ggplot(pheob_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1932, xmax=1962, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=pheob_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,1500))+
  scale_y_continuous(breaks=seq(0, 1500, 300))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
   labs(y="", x="", title=c(expression(paste("Pheophytin ",italic("b")))),
       subtitle="Chlorophytes")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
pheob_plot
#Yay it works!



###Separately for Yvonne
pheob_long_sky<- pheob_long %>%
  filter(lake_ID=="SkyPond")
pheob_long_loch<- pheob_long %>%
  filter(lake_ID=="TheLoch")

skypheob_plot<-  pheobYear_S%>%
  ggplot(aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1932, xmax=1962, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=pheob_long_sky, mapping=aes(x=age_sky, y=response), size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,1500),xlim=c(1600,2000))+
  scale_y_continuous(breaks=seq(0, 1500, 300))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
   # labs(y="", x="", title=c(expression(paste("Pheophytin ",italic("b")))),
   #     subtitle="Chlorophytes")+
       labs(y="", x="", title="Sky Pond")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none",
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        plot.margin=unit(c(0,0,0,0.5), "lines"))
  
lochpheob_plot<-    pheobYear_L%>%
  ggplot(aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1932, xmax=1962, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=pheob_long_loch, mapping=aes(x=age_sky, y=response),  size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,600),xlim=c(1600,2000))+
  scale_y_continuous(breaks=seq(0, 600, 100))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="Year", title="The Loch")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none",
        plot.margin=unit(c(0,0,0,0.5), "lines"))

lochskypheob_plot<-ggarrange(skypheob_plot, lochpheob_plot,
                           ncol = 1, nrow = 2,
                           align="hv",
                           labels = c("A", "B"),
                           font.label = list(size = 12, face="bold"),
                           # widths = c(1,1), heights = c(2,2.6),
                           # common.legend = TRUE,
                           legend = "none")
annotate_figure(lochskypheob_plot,
                left = text_grob(expression(Pheophytin~italic("b")~concentration~(nmol*~g^-1~organic~carbon)),
                                 color = "black", face="bold", size=12, rot = 90))

```

### DIATOMS

#### Fuco GAMs Sky
```{r}

# **Diatoms: Fuco GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Lutein

### I added Family Gamma here for how errors should respond
mod_fuco_S <- gamm(fuco ~ s(age_sky, k =10), family=Gamma(link="log"), data = sky_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
fucoPhi_S <- intervals(mod_fuco_S$lme, which = "var-cov")$corStruct
fucoPhi_S

## summary object for use in document
fucoSumm_S <- summary(mod_fuco_S$gam)
fucoSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_fuco_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
fucoYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
fucoYear_S <- cbind(fucoYear_S, data.frame(predict(mod_fuco_S$gam, fucoYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
fucoYear_S <- transform(fucoYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
fucoYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
fuco_fitted_S <- ggplot(fucoYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = fuco), inherit.aes = FALSE) +
  geom_line() 
fuco_fitted_S
```

#### Fuco GAMs Loch
```{r}

# **Diatoms: Fuco GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch Lutein

### I added Family Gamma here for how errors should respond

mod_fuco_L <- gamm(fuco ~ s(age_sky, k = 5), family=Gamma(link="log"), data = loch_wide,
                    correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
fucoPhi_L <- intervals(mod_fuco_L$lme, which = "var-cov")$corStruct
fucoPhi_L

## summary object for use in document
fucoSumm_L <- summary(mod_fuco_L$gam)
fucoSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_fuco_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
fucoYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
fucoYear_L <- cbind(fucoYear_L, data.frame(predict(mod_fuco_L$gam, fucoYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
fucoYear_L <- transform(fucoYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
fucoYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
fuco_fitted_L <- ggplot(fucoYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = fuco), inherit.aes = FALSE) +
  geom_line() 
fuco_fitted_L
```

###### plot fuco
```{r}
#Plot in MS form
fuco_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="fuco")

fuco_CI <- bind_rows(fucoYear_L, fucoYear_S)


fuco_plot<-ggplot(fuco_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  geom_point(data=fuco_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,1000))+
  scale_y_continuous(breaks=seq(0, 1000, 200))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="", title="Fucoxanthin")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))

#Yay it works!
```


#### Diatox GAMs Sky
```{r}
# **Diatoms: Diatox GAMs Sky --------------------------------------------
#4
### I added Family Gamma here for how errors should respond
mod_diatox_S <- gamm(diato ~ s(age_sky, k = 4), family=Gamma(link="log"), data = sky_wide,
                    # correlation = corCAR1(form = ~ age_sky),
                    method = "REML")

## estimate of phi and confidence interval
diatoxPhi_S <- intervals(mod_diatox_S$lme, which = "var-cov")$corStruct
diatoxPhi_S

## summary object for use in document
diatoxSumm_S <- summary(mod_diatox_S$gam)
diatoxSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_diatox_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
diatoxYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
diatoxYear_S <- cbind(diatoxYear_S, data.frame(predict(mod_diatox_S$gam, diatoxYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
diatoxYear_S <- transform(diatoxYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
diatoxYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
diatox_fitted_S <- ggplot(diatoxYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = diato), inherit.aes = FALSE) +
  geom_line() 
diatox_fitted_S
```



###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_diatox_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(diatoxYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(diatoxYear_S, range(upper, lower, fit))
ylab <- "diatox"

plot(fit ~ age_sky, data = diatoxYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = diatoxYear_S)
lines(upper ~ age_sky, data = diatoxYear_S, lty = "dashed")
lines(lower ~ age_sky, data = diatoxYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = diatoxYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = diatoxYear_S, col = "red", lwd = 3)

incr<-data.frame(unlist(m2.dsig$incr), diatoxYear_S$age_sky)
####1784-1891
decr<-data.frame(unlist(m2.dsig$decr), diatoxYear_S$age_sky)
####1915-present

```



#### Diatox GAMs Loch
```{r}
# **Diatoms: Diatox GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch diatox

### I added Family Gamma here for how errors should respond

mod_diatox_L <- gamm(diato ~ s(age_sky, k = 4), family=Gamma(link="log"), data = loch_wide,
                    # correlation = corCAR1(form = ~ age_sky),
                    method = "REML")

## estimate of phi and confidence interval
diatoxPhi_L <- intervals(mod_diatox_L$lme, which = "var-cov")$corStruct
diatoxPhi_L

## summary object for use in document
diatoxSumm_L <- summary(mod_diatox_L$gam)
diatoxSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_diatox_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
diatoxYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
diatoxYear_L <- cbind(diatoxYear_L, data.frame(predict(mod_diatox_L$gam, diatoxYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
diatoxYear_L <- transform(diatoxYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
diatoxYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
diatox_fitted_L <- ggplot(diatoxYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = diato), inherit.aes = FALSE) +
  geom_line() 
diatox_fitted_L
```

###### plot diatox
```{r}
#MS Plot
diatox_long <- master_core_long %>%
  filter(proxy_ID=="diato")

diatox_CI <- bind_rows(diatoxYear_L, diatoxYear_S)


diatox_plot<-ggplot(diatox_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1860, xmax=1877, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=diatox_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  # coord_cartesian(ylim=seq(0,900))+
  scale_y_continuous(limits=c(0, 900), breaks=seq(0, 900, 150))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="", title="Diatoxanthin",
       subtitle="Diatoms")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))

diatox_plot
```

####Diatox/Pheo GAMs Sky
```{r}

# Diatox/Pheo a GAMs Sky --------------------------------------------
#4
### I added Family Gamma here for how errors should respond
mod_perc_diatox_S <- gamm(perc_diatox ~ s(age_sky, k = 7), family=Gamma(link="log"), data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
perc_diatoxPhi_S <- intervals(mod_perc_diatox_S$lme, which = "var-cov")$corStruct
perc_diatoxPhi_S

## summary object for use in document
perc_diatoxSumm_S <- summary(mod_perc_diatox_S$gam)
perc_diatoxSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_perc_diatox_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
perc_diatoxYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
perc_diatoxYear_S <- cbind(perc_diatoxYear_S, data.frame(predict(mod_perc_diatox_S$gam, perc_diatoxYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
perc_diatoxYear_S <- transform(perc_diatoxYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
perc_diatoxYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
perc_perc_diatox_fitted_S <- ggplot(perc_diatoxYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = perc_diatox), inherit.aes = FALSE) +
  geom_line() 
perc_perc_diatox_fitted_S
```

####Diatox/Pheo GAMs Loch
```{r}
# **Perc Diatoms:Diatox/Pheo a GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch perc_diatox

### I added Family Gamma here for how errors should respond

mod_perc_diatox_L <- gamm(perc_diatox ~ s(age_sky, k = 4), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
perc_diatoxPhi_L <- intervals(mod_perc_diatox_L$lme, which = "var-cov")$corStruct
perc_diatoxPhi_L

## summary object for use in document
perc_diatoxSumm_L <- summary(mod_perc_diatox_L$gam)
perc_diatoxSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_perc_diatox_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
perc_diatoxYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
perc_diatoxYear_L <- cbind(perc_diatoxYear_L, data.frame(predict(mod_perc_diatox_L$gam, perc_diatoxYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
perc_diatoxYear_L <- transform(perc_diatoxYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
perc_diatoxYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
perc_diatox_fitted_L <- ggplot(perc_diatoxYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = perc_diatox), inherit.aes = FALSE) +
  geom_line() 
perc_diatox_fitted_L
```

#####plot diatox/pheo
```{r}
#MS Plot
perc_diatox_long <- master_core_long %>%
  filter(proxy_ID=="perc_diatox")

perc_diatox_CI <- bind_rows(perc_diatoxYear_L, perc_diatoxYear_S)


perc_diatox_plot<-ggplot(perc_diatox_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  geom_point(data=perc_diatox_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
    annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  # coord_cartesian(ylim=seq(0,1000))+
  # scale_y_continuous(breaks=seq(0, 1000, 200))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="Proportion", x="", title="Diatoxanthin:Pheophytin a")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom")+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))

#For Cary seminar
perc_diatox_long2<-perc_diatox_long%>%
  filter(lake_ID=="SkyPond")
perc_diatox_CI %>%
  filter(lake_ID=="SkyPond")%>%
ggplot(aes(x=age_sky,y=fit, color=lake_ID))+
  geom_point(data=perc_diatox_long2, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
    # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=seq(0,1),
                  xlim=seq(1850,2000))+
  # scale_y_continuous(breaks=seq(0, 1000, 200))+
  scale_x_continuous(breaks=seq(1850, 2000, 25))+
  labs(y="Diatoxanthin:Pheophytin a", x="", title="")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="none")+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))

```

### OTHER PIGMENTS

#### Echinenone GAMs Sky

```{r}

# **Other: Echinenone GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Echinenone

### I added Family Gamma here for how errors should respond
mod_echine_S <- gamm(echine ~ s(age_sky, k =5), family=Gamma(link="log"), data = sky_wide,
                   correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
echinePhi_S <- intervals(mod_echine_S$lme, which = "var-cov")$corStruct
echinePhi_S

## summary object for use in document
echineSumm_S <- summary(mod_echine_S$gam)
echineSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_echine_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
echineYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
echineYear_S <- cbind(echineYear_S, data.frame(predict(mod_echine_S$gam, echineYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
echineYear_S <- transform(echineYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
echineYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
echine_fitted_S <- ggplot(echineYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = echine), inherit.aes = FALSE) +
  geom_line() 
echine_fitted_S
```




###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_echine_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(echineYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(echineYear_S, range(upper, lower, fit))
ylab <- "echine"

plot(fit ~ age_sky, data = echineYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = echineYear_S)
lines(upper ~ age_sky, data = echineYear_S, lty = "dashed")
lines(lower ~ age_sky, data = echineYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = echineYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = echineYear_S, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), echineYear_S$age_sky)
```






#### Echinenone GAMs Loch
```{r}
# **Other: Echinenone GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch echine

### I added Family Gamma here for how errors should respond

mod_echine_L <- gamm(echine ~ s(age_sky, k = 5), family=Gamma(link="log"), data = loch_wide,
                   correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
echinePhi_L <- intervals(mod_echine_L$lme, which = "var-cov")$corStruct
echinePhi_L

## summary object for use in document
echineSumm_L <- summary(mod_echine_L$gam)
echineSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_echine_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
echineYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
echineYear_L <- cbind(echineYear_L, data.frame(predict(mod_echine_L$gam, echineYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
echineYear_L <- transform(echineYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
echineYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
echine_fitted_L <- ggplot(echineYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = echine), inherit.aes = FALSE) +
  geom_line() 
echine_fitted_L
```

###### plot echinenone
```{r}

#Plot in MS form
echine_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="echine")

echine_CI <- bind_rows(echineYear_L, echineYear_S)


echine_plot<-ggplot(echine_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=echine_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  scale_y_continuous(breaks=seq(0, 60, 10))+
  coord_cartesian(ylim=c(0,60))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="", title="Echinenone",
       subtitle="Total cyanobacteria")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
echine_plot

```

#### Canthaxanthin GAMs Sky
```{r}
# **Other: Canthaxanthin GAMs Sky --------------------------------------------

### I added Family Gamma here for how errors should respond
mod_cantha_S <- gamm(cantha ~ s(age_sky, k = 8), family=Gamma(link="log"), data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
canthaPhi_S <- intervals(mod_cantha_S$lme, which = "var-cov")$corStruct
canthaPhi_S

## summary object for use in document
canthaSumm_S <- summary(mod_cantha_S$gam)
canthaSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_cantha_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
canthaYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
canthaYear_S <- cbind(canthaYear_S, data.frame(predict(mod_cantha_S$gam, canthaYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
canthaYear_S <- transform(canthaYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
canthaYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
cantha_fitted_S <- ggplot(canthaYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = cantha), inherit.aes = FALSE) +
  geom_line() 
cantha_fitted_S
```

###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_cantha_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(canthaYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(canthaYear_S, range(upper, lower, fit))
ylab <- "cantha"

plot(fit ~ age_sky, data = canthaYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = canthaYear_S)
lines(upper ~ age_sky, data = canthaYear_S, lty = "dashed")
lines(lower ~ age_sky, data = canthaYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = canthaYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = canthaYear_S, col = "red", lwd = 3)


incr<-data.frame(unlist(m2.dsig$incr), canthaYear_S$age_sky)
```




#### Canthaxanthin GAMs Loch
```{r}
# **Other: Canthaxanthin GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch cantha

### I added Family Gamma here for how errors should respond

mod_cantha_L <- gamm(cantha ~ s(age_sky, k = 4), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
canthaPhi_L <- intervals(mod_cantha_L$lme, which = "var-cov")$corStruct
canthaPhi_L

## summary object for use in document
canthaSumm_L <- summary(mod_cantha_L$gam)
canthaSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_cantha_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
canthaYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
canthaYear_L <- cbind(canthaYear_L, data.frame(predict(mod_cantha_L$gam, canthaYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
canthaYear_L <- transform(canthaYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
canthaYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
cantha_fitted_L <- ggplot(canthaYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = cantha), inherit.aes = FALSE) +
  geom_line() 
cantha_fitted_L
```

###### plot canthanxanthin
```{r}
#MS Plot
cantha_long <- master_core_long %>%
  filter(proxy_ID=="cantha")

cantha_CI <- bind_rows(canthaYear_L, canthaYear_S)


cantha_plot<-ggplot(cantha_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
    # annotate("rect", xmin=1940, xmax=1975, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_point(data=cantha_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,150))+
  scale_y_continuous(breaks=seq(0, 150, 25))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="", title="Canthaxanthin",
       subtitle="Nostocales cyanobacteria")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_text(size=24),
        axis.text.x=element_text(size=24, angle = 45, vjust=0.55))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
cantha_plot
```

#### Myxoxanthophyll GAMs Sky
```{r}
# **Other: Myxoxanthophyll GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Myxoxanthophyll

#No GAMS because only zero values

```

#### Myxoxanthophyll GAMs Loch
```{r}
# **Other: Myxoxanthophyll GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch myxo

### I added Family Gamma here for how errors should respond

mod_myxo_L <- gamm(myxo ~ s(age_sky, k = 5), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
myxoPhi_L <- intervals(mod_myxo_L$lme, which = "var-cov")$corStruct
myxoPhi_L

## summary object for use in document
myxoSumm_L <- summary(mod_myxo_L$gam)
myxoSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_myxo_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
myxoYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
myxoYear_L <- cbind(myxoYear_L, data.frame(predict(mod_myxo_L$gam, myxoYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
myxoYear_L <- transform(myxoYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
myxoYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
myxo_fitted_L <- ggplot(myxoYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = myxo), inherit.aes = FALSE) +
  geom_line() 
myxo_fitted_L
```

###### plot myxoxanthophyll
```{r}
#Plot in MS form
myxo_long <-master_core_long %>% #sample_data_long
  filter(proxy_ID=="myxo")

myxo_CI <- bind_rows(myxoYear_L)


myxo_plot<-ggplot(myxo_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=myxo_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,120))+
  scale_y_continuous(breaks=seq(0, 120, 20))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="Year", title="Myxoxanthophyll",
       subtitle="Colonial cyanobacteria")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#8856a7", "#8856a7"))+
  theme(legend.position="none",
        # axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
myxo_plot

```

#### Alloxanthin GAMs Sky
```{r}
# **Other: Alloxanthin GAMs Sky --------------------------------------------


###########Fitting GAMs for Sky Pond Alloxanthin

### I added Family Gamma here for how errors should respond
mod_allo_S <- gamm(allo ~ s(age_sky, k =5), family=Gamma(link="log"), data = sky_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")

## estimate of phi and confidence interval
alloPhi_S <- intervals(mod_allo_S$lme, which = "var-cov")$corStruct
alloPhi_S

## summary object for use in document
alloSumm_S <- summary(mod_allo_S$gam)
alloSumm_S #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_allo_S$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
alloYear_S <- with(sky_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
alloYear_S <- cbind(alloYear_S, data.frame(predict(mod_allo_S$gam, alloYear_S, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
alloYear_S <- transform(alloYear_S, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
alloYear_S$lake_ID <- 'SkyPond'

## Plot simulated trends
allo_fitted_S <- ggplot(alloYear_S, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = sky_wide, mapping = aes(x = age_sky, y = allo), inherit.aes = FALSE) +
  geom_line() 
allo_fitted_S
```


###### Periods of change
```{r}
#https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
Term <- "age_sky"
m2.d <- Deriv(mod_allo_S)
m2.dci <- confint(m2.d, term = "age_sky")
m2.dsig <- signifD(alloYear_S$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(alloYear_S, range(upper, lower, fit))
ylab <- "allo"

plot(fit ~ age_sky, data = alloYear_S, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ age_sky, data = alloYear_S)
lines(upper ~ age_sky, data = alloYear_S, lty = "dashed")
lines(lower ~ age_sky, data = alloYear_S, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ age_sky, data = alloYear_S, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ age_sky, data = alloYear_S, col = "red", lwd = 3)

decr<-data.frame(unlist(m2.dsig$decr), alloYear_S$age_sky)
incr<-data.frame(unlist(m2.dsig$incr), alloYear_S$age_sky)
```


#### Alloxanthin GAMs Loch
```{r}
# **Other: Alloxanthin GAMs Loch --------------------------------------------


###########Fitting GAMs for The Loch Alloxanthin

### I added Family Gamma here for how errors should respond

mod_allo_L <- gamm(allo ~ s(age_sky, k = 5), family=Gamma(link="log"), data = loch_wide,
                     correlation = corCAR1(form = ~ age_sky), method = "REML")


## estimate of phi and confidence interval
alloPhi_L <- intervals(mod_allo_L$lme, which = "var-cov")$corStruct
alloPhi_L

## summary object for use in document
alloSumm_L <- summary(mod_allo_L$gam)
alloSumm_L #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model (I didn't check)
gam.check(mod_allo_L$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in
### type of predict()
alloYear_L <- with(loch_wide, data.frame(age_sky = seq(min(age_sky), max(age_sky), length.out = 200)))
alloYear_L <- cbind(alloYear_L, data.frame(predict(mod_allo_L$gam, alloYear_L, type="response", se.fit = TRUE)))
### this calculates on the link scale (i.e., log)
alloYear_L <- transform(alloYear_L, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
alloYear_L$lake_ID <- 'TheLoch'

## Plot simulated trends
allo_fitted_L <- ggplot(alloYear_L, aes(x = age_sky, y = fit)) +
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = loch_wide, mapping = aes(x = age_sky, y = allo), inherit.aes = FALSE) +
  geom_line() 
allo_fitted_L
```

###### plot alloxanthin
```{r}
#Plot in MS form
allo_long <- master_core_long %>% #sample_data_long
  filter(proxy_ID=="allo")

allo_CI <- bind_rows(alloYear_L, alloYear_S)


allo_plot<-ggplot(allo_CI,aes(x=age_sky,y=fit, color=lake_ID))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(data=allo_long, mapping=aes(x=age_sky, y=response), , size=2.5, alpha=0.7) +
  geom_line(size=1)+
  geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, fill=lake_ID), alpha = 0.5, inherit.aes = FALSE) +
  coord_cartesian(ylim=c(0,240))+
  scale_y_continuous(breaks=seq(0, 240, 40))+
  scale_x_continuous(breaks=seq(1600, 2000, 50))+
  labs(y="", x="\nYear", title="Alloxanthin",
       subtitle="Cryptophytes")+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="bottom",
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
allo_plot

```

# FIGURES
###Figure 2 - Chronology
```{r}
dating <- read.csv("data/raw/Pb210_trim.csv")
glimpse(dating)

# **Panel A - Pb210 vs depth --------------------------------------------
pb210_depth<-ggplot(dating,aes(x=mid_depth,y=ln_PB_210))+
  geom_point(data=dating, mapping=aes(x=mid_depth, y=ln_PB_210_exclude), size=2.5, alpha=0.7, color="black", fill="white", shape=1) +
  geom_point(size=4, color="black", fill="black", shape=19) +
  geom_smooth(method=lm, se=FALSE, color="black", linetype=1)+
  coord_cartesian(ylim=c(0,5), xlim=c(0,15))+
  scale_y_continuous(breaks=seq(0, 5, 1))+
  scale_x_continuous(breaks=seq(0, 15, 5))+
  # labs(y="ln 210-Pb", x="Depth (cm)")+
  labs(y=expression(paste(ln ^{210}, "Pb")), x="Depth (cm)")+
  theme(legend.position="bottom", legend.text = element_text(size=12),
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))+
  geom_text(size=10, aes(x = 8.5, y = 4.5, 
                        label = "r^2 == 0.8038"), parse = TRUE) + 
  geom_text(size=10,aes(x = 10, y = 5, 
                       label = "y = -0.5311x + 4.9292")) 
pb210_depth

# **Panel B - Cs actvity vs depth --------------------------------------------
cs137_depth<-ggplot(dating,aes(x=mid_depth,y=Cs_137_activity_dpm_g))+
  geom_point(size=4, color="black", fill="black", shape=19) +
  geom_line(size=0.5)+
  coord_cartesian(ylim=c(0,30), xlim=c(0,15))+
  scale_y_continuous(breaks=seq(0, 30, 10))+
  scale_x_continuous(breaks=seq(0, 15, 5))+
  # labs(y="Cs activity (dpm/g)", x="Depth (cm)")+
  labs(y=expression(Cs~activity~(dpm*~g^-1)), x="Depth (cm)")+
  theme(legend.position="bottom", legend.text = element_text(size=12),
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
cs137_depth

# **Panel C - Age  vs depth --------------------------------------------
age_depth<-ggplot(dating,aes(x=mid_depth,y=date_at_depth))+
  geom_point(size=4, color="black", fill="black", shape=19) +
  geom_line(size=0.5)+
  coord_cartesian(ylim=c(1850,2010), xlim=c(0,15))+
  scale_y_continuous(breaks=seq(1850, 2010, 50))+
  scale_x_continuous(breaks=seq(0, 15, 5))+
  labs(y="Year", x="Depth (cm)")+
  theme(legend.position="bottom", legend.text = element_text(size=12))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
age_depth

# ~~~~~~ DATING: MS Plot --------------------------------------------------

ggarrange(pb210_depth,cs137_depth, age_depth, 
          labels = c("A", "B","C"),
          font.label = list(size = 30, face="bold"),
          align="v",
          ncol = 1, nrow = 3,
          widths = c(2,2,2), heights = c(1,1,1.2))

ggsave("figures/MS/figure1_chronology_revision.png", width=8, height=19.2,units="in")
```

###Figure 3 - Loch vs.Sky z-scores
```{r}

zboth_plot <-master_core_long %>%
  filter(proxy_ID=="del15N_zscore") %>%
  filter(response < 2) %>% 
  ggplot(aes(x=sample_start_depth,y=response, color=lake_ID))+
  geom_point(size=4, ) +
  # geom_smooth(method=mgcv::gamm, formula=y~s(x, k=7),  color="black")+
  # coord_cartesian(ylim=seq(-28,-22))+
  labs(y=expression(paste(delta^{15}, "N (‰)", " z-score")), x="Depth (cm)")+
  # geom_smooth(data=subset(zboth, sample_start_depth <= 8), method='lm',formula=y~x,se=F)+
  # scale_y_continuous(breaks=seq(-28,-22, 1))+
  # scale_x_continuous(breaks=seq(1600, 2000, 50))+
  scale_color_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  scale_fill_manual(
    name="",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values=c("#9ebcda", "#8856a7"))+
  theme(legend.position="top")+
  guides(shape = guide_legend(override.aes = list(size=6)))
zboth_plot


x <- zscores_master[,1]
y <- zscores_master[,3]
cor(x,y, method="pearson")


corr_plot_z <- ggscatter(zscores_master, x="loch_z", y="sky_z",
                         add="reg.line",conf.int=TRUE,
                         cor.coef=TRUE, cor.method="pearson",
                         cor.coeff.args = list(method = "pearson", label.sep = "\n"),
                         cor.coef.size = 10,
                         size=2.5,
                         xlab="Sky z-score",
                         ylab="Loch z-score")+
  theme_paleo()
corr_plot_z

z_scores_stacked <- ggarrange(zboth_plot,corr_plot_z, 
                              ncol = 1, nrow = 2, align="v",
                              labels = c("A", "B"),
                              font.label = list(size = 30, face="bold"),
                              widths = c(2,2), heights = c(1.2,1))
ggsave("figures/MS/figure3_zscores_resubmission.png", width=8, height=10,units="in")

```

###Figure 4 - Geochemical
```{r}
# ggarrange(percN_plot, percC_plot,CN_plot,del13C_plot,
#           labels = c("A", "B","C","D"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 4,
#           widths = c(2,2,2,2), heights = c(1,1,1,1.6))
# 
# ggsave("figures/MS/figure4_elements_resubmission_noGAMs.png", width=10, height=22,units="in")
# 
# 
# 
#Revised figure for Proc B
# ggarrange(del15N_plot,percN_plot, percC_plot,CN_plot,del13C_plot,
#           labels = c("A", "B","C","D","E"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 5,
#           widths = c(2,2,2,2,2), heights = c(1,1,1,1,1.4))
# 
# ggsave("figures/MS/figure4_elements_procBresubmission_5panel.png", width=10, height=22,units="in", dpi=600)
# 

del13C_plot <- del13C_plot +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())
ggarrange(del13C_plot,del15N_plot,percC_plot,percN_plot,CN_plot,
          labels = c("A", "B","C","D","E"),
          font.label = list(size = 12, face="bold"),
          align="v",
          ncol = 1, nrow = 5,
          common.legend=TRUE,
          legend="bottom",
          widths = c(2,2,2,2,2), heights = c(1,1,1,1,1.1))

# ggsave("figures/MS/figure1_elements_procBresubmission_5panel.png", width=10, height=23,units="in", dpi=600)
ggsave("figures/MS/figure1_elements_procBresubmission_5panel_small.png", width=4, height=9.5, units="in", dpi=600)


# #For defense
# CN_plot2 <- CN_plot +
#   theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55))
# 
# 
# ggarrange(del15N_plot, del13C_plot,CN_plot2,
#           labels = c("A", "B","C"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 3,
#           widths = c(2,2,2), heights = c(1,1,1.3))
# 
# ggsave("figures/defense/paleo_elements.png", width=12, height=18,units="in")


```

### Figure 5 - All pigments
```{r}
lutein_plot2 <- lutein_plot +
  theme(axis.text.x = element_blank(),
        axis.title.x=element_blank())

cantha_plot2 <- cantha_plot +
  theme(axis.title.x=element_text(size=12),
        axis.text.x=element_text(size=12, angle = 45, vjust=0.55))


allo_plot2 <- allo_plot +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_text(size=12, angle = 45, vjust=0.55))


myxo_plot2 <- myxo_plot +
  theme(axis.text.x=element_text(size=12, angle = 45, vjust=0.55))



AtoF <- ggarrange(pheoa_plot,bcar_plot,pheob_plot,
                  lutein_plot2,diatox_plot,echine_plot,
                  labels = c("A", "B","C","D","E","F"),
                  font.label = list(size = 12, face="bold"),
                  ncol = 3, nrow = 2, align="hv",
                  # widths = c(2,2,2,2,2,2,2,2,2), heights = c(1,1,1,1,1,1,1.7,1.3,1.3),
                  common.legend = TRUE, legend = "none")
all_pigments <- ggarrange(AtoF,
                          ggarrange(
                            cantha_plot2,myxo_plot2,allo_plot2,
                            labels = c("G","H","I"),
                            font.label = list(size = 12, face="bold"),
                            ncol = 3, nrow = 1, align="h",
                            common.legend=TRUE, legend="bottom"),
                            nrow=2,
                            heights = c(1.5,1),
                            align="hv")
annotate_figure(all_pigments,
                left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)),
                                 color = "black", face="bold", size=12, rot = 90)
                # left = text_grob("Pigment concentration (nmol/g organic carbon)", color = "black", face="bold", size=32, rot = 90)
)
# ggsave("figures/MS/figure2_all_pigments_procB_FINAL_600dpi.jpg", width=18, height=18,units="in", dpi=600)
ggsave("figures/MS/figure2_all_pigments_procB_FINAL_600dpi_small.jpg", width=9, height=9,units="in", dpi=600)


# 
# 
#Total in lake production
# bcar_plot2 <- bcar_plot +
#   theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55))
# 
# 
# totalprod<-ggarrange(pheoa_plot, bcar_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# annotate_figure(totalprod,
#                 left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)), color = "black", face="bold", size=32, rot = 90))
# 
# 
# ggsave("figures/defense/paleo_totalprod.png", width=12, height=18,units="in")
# 
# 
# 
# # Total chlorophytes
# lutein_plot2 <- lutein_plot +
#    labs(y="", x="", title=c(expression(paste("Pheophytin ",italic("b")))),
#        subtitle="Green algae")+
#   theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55))
# 
# pheob_plot2 <- pheob_plot +
#   labs(y="", x="", title=c(expression(paste("Lutein & Zeaxanthin"))),
#        subtitle="Green algae and cyanobacteria")
# greens<- ggarrange(pheob_plot2, lutein_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# annotate_figure(greens,
#                 left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)), color = "black", face="bold", size=32, rot = 90))
# 
# ggsave("figures/defense/paleo_chlorophytes.png", width=12, height=18,units="in")
# 
# #Diatom action!!
# diatox_plot2 <- diatox_plot +
#   theme(axis.text.x=element_blank())+
#   labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# 
# 
# diatox_plot3 <- diatox_plot +
#   theme(axis.text.x=element_blank())+
#   labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# diatox_plot3
# # ggsave("figures/defense/paleo_diatox_alone.png", width=12, height=12,units="in")
# 
# 
# perc_diatox_plot2 <- perc_diatox_plot +
#     theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55)) 
# 
# 
# ggarrange(diatox_plot2, perc_diatox_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# 
# ggsave("figures/defense/paleo_diatoms.png", width=12, height=18,units="in")
# 
# 
# diatox_plot4 <- diatox_plot + 
#     labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# PB2 <- diatom_full %>%
#   ggplot(aes(x=age_sky,y=PB, label=INSTAAR_accession_num))+
#   geom_point(size=4,color="grey50") +
#   labs(y="Ratio", x="", title="Planktonic:Benthic")+
#   geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE, color="black", linetype=2) +
#   # geom_smooth(aes(x=age_sky,y=PB), method="gam",se=FALSE, color="black", linetype=2)+
#   scale_y_continuous(breaks=seq(0,1.25, 0.25))+
#   scale_x_continuous(breaks=seq(1600, 2000, 50))+
#   coord_cartesian(ylim=c(0,1.25),
#                   xlim=c(1600,2010))+
#   scale_fill_manual(
#     name="\n",
#     breaks=c("SkyPond","TheLoch"),
#     labels=c("Sky Pond","The Loch"),
#     values = c(0, 16))+
#   theme(legend.position="bottom", legend.text = element_text(size=12),
#         axis.text.x=element_text(size=24, angle = 45, vjust=0.55))+
#   guides(shape = guide_legend(override.aes = list(size=10)),
#          color = guide_legend(override.aes = list(linetype = 0)))
#   
# 
# 
# 
# ggarrange(diatox_plot4, PB2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# 
# ggsave("figures/defense/paleo_diatox_and_PB.png", width=12, height=18,units="in")
# 



```

###Figure 6 - Sky BP
```{r}

specieswithdate <- read.csv("/Users/solomonlab/Google Drive/Research (common)/Research/Data/R/paleo/data/output/specieswithdates.csv")

B_P_separate<- specieswithdate %>%
  filter(age_sky > 1850) %>%
ggplot(aes(x=age_sky,y=total, shape=PLANK_B, color=PLANK_B))+
  # annotate("rect", xmin=1850, xmax=2020, ymin=0, ymax=Inf, alpha=0.1, fill="grey10") +
  geom_point(size=4) +
  # geom_line(size=1)+
  # geom_ribbon(aes(ymin = (lower), ymax = (upper), x = age_sky, group=lake_ID), alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  # coord_cartesian(xlim=c(1850,2010))+
  coord_cartesian(ylim=c(0,100))+
  # scale_y_continuous(breaks=seq(0, 20, 4))+
  scale_x_continuous(breaks=seq(1850, 2010, 50))+
  scale_color_manual(
    name="",
    breaks=c("B","PLANK"),
    labels=c("Benthic","Planktonic"),
    values=c("#5e4fa2", "#f46d43"))+
  scale_fill_manual(
    name="",
    breaks=c("B","PLANK"),
    labels=c("Benthic","Planktonic"),
    values=c("#9ebcda", "#8856a7"))+
  labs(y="Total # valves counted", x="\nYear")+
  theme(legend.position="top", legend.text = element_text(size=12),
        axis.title.x=element_blank(),
        axis.text.x=element_blank())+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
B_P_separate



PB <- diatom_full %>%
  filter(age_sky > "1850") %>%  
  ggplot(aes(x=age_sky,y=PB, label=INSTAAR_accession_num))+
  geom_point(size=5,shape=21,color="black",fill="grey50") +
  labs(y="Planktonic:Benthic ratio", x="Year", title="")+
  # geom_smooth(method = lm, formula = y ~ splines::bs(x, 4), se = FALSE, color="black", linetype=2) +
  # geom_smooth(aes(x=age_sky,y=PB), method="gam",se=FALSE, color="black", linetype=2)+
  scale_y_continuous(breaks=seq(0,1.25, 0.25))+
  scale_x_continuous(breaks=seq(1850, 2000, 25))+
  coord_cartesian(ylim=c(0,1.25),
                  xlim=c(1850,2010))+
  scale_fill_manual(
    name="\n",
    breaks=c("SkyPond","TheLoch"),
    labels=c("Sky Pond","The Loch"),
    values = c(0, 16))+
  theme(legend.position="bottom",
        legend.text = element_text(size=12))+
  guides(shape = guide_legend(override.aes = list(size=10)),
         color = guide_legend(override.aes = list(linetype = 0)))
  
PB
 ggsave("figures/MS/Figure6_PB_alone_resubmission_FINAL_600dpi.png", width=8, height=6,units="in", dpi=600)
PB2 <- PB +
      theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55)) 
PB2
# ggsave("figures/defense/paleo_PB_alone.png", width=12, height=12,units="in")


B_P_stacked <- ggarrange(B_P_separate,PB, 
                               ncol = 1, nrow = 2, align="v",
                               labels = c("A", "B"),
                               font.label = list(size = 30, face="bold"),
                               widths = c(2,2), heights = c(1,1))
ggsave("figures/MS/figure6_resubmission_PB.png", width=8, height=12,units="in")

```

###Figure 7 - Water & air temp trends
####Loch water temperature
```{r}

synoptic <- read.csv("data/raw/LVWS_surfacewaterchemistry_MASTER_170524.csv")
head(synoptic)
str(synoptic)


S.1983.LO <- synoptic %>%
  filter(YEAR > 1983) %>%#selectingyears after 1983
  filter(SITE == "LOCH.O" & TYPE == "NORMAL")#selecting the Loch outlet, NORMAL samples

####DATE CONVERSION###
library(lubridate) #To tell R that my dates are dates
str(S.1983.LO$DATE)
S.1983.LO$DATE <- mdy(as.character(S.1983.LO$DATE))


S.1983.LO$doy=strptime(S.1983.LO$DATE,format="%m/%d/%Y")$yday  #converting date to day of year


#Before plotting with GGPLOT2, the data needs to be reformatted
# ggplot requires a “slightly” different table structure.
#Think of it as having a long sample with three columns
LOCH_TEMP <- S.1983.LO %>%
  select(DATE, TEMP)

LOCH_TEMP <- melt(LOCH_TEMP,id.vars="DATE",na.rm=TRUE)
str(LOCH_TEMP)
#Create a new column that has just the year
LOCH_TEMP <- LOCH_TEMP %>%
  mutate(Year = year(DATE),
         Month = month(DATE))

LOCH_TEMP_JULY_SUMM <- LOCH_TEMP %>%
  filter(Month=="7") %>%
  group_by(Year) %>%
  summarize(mean_temp=mean(value),
            sd_temp=sd(value))

LOCH_TEMP_JJA_SUMM <- LOCH_TEMP %>%
  filter(Month %in% c("6","7","8")) %>%
  group_by(Year) %>%
  summarize(mean_temp=mean(value),
            sd_temp=sd(value))

mod_julytemps=lm(mean_temp~as.numeric(Year), data=LOCH_TEMP_JULY_SUMM)
summary(mod_julytemps)

mod_JJAtemps=lm(mean_temp~as.numeric(Year), data=LOCH_TEMP_JJA_SUMM)
summary(mod_JJAtemps)


###July temperature 
pd <- position_dodge(0.1) # move them .05 to the left and right
temp_july_means <- ggplot(LOCH_TEMP_JULY_SUMM,aes(x=Year,y=mean_temp))  + 
  geom_point(position=pd, size=6, shape=16, color="#2c7fb8") + # Create line with series and specify its thickness
  geom_errorbar(aes(ymin=mean_temp-sd_temp, ymax=mean_temp+sd_temp), colour="black", width=.3, position=pd) +
  geom_smooth(method=lm, se=FALSE, color="black", linetype=2)+
  coord_cartesian(ylim=c(0,16),xlim=c(1984,2016))+
  # scale_y_continuous(name = expression("Water temperature " ( degree*C)), breaks=seq(0, 20, 2)) +
  scale_y_continuous(name = expression("July"~"T"["water "] (degree*C)),breaks=seq(0, 20, 2))+ 
  scale_x_continuous(name = "Year", breaks=seq(1984, 2016, 4))+
  labs(x="Year",y="Temp", title="July only")+
  geom_text(size=6, aes(x = 1988, y = 16, 
                label = "r^2 == 0.16"), parse = TRUE) + 
  geom_text(size=6,aes(x = 1988, y = 15, 
                label = "p = 0.024")) +
  geom_text(size=6,aes(x = 1988, y = 14, 
                label = "y = 0.065x - 121.27")) +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())
temp_july_means


###Summer temperatures
pd <- position_dodge(0.1) # move them .05 to the left and right
temp_JJA_means <- ggplot(LOCH_TEMP_JJA_SUMM,aes(x=Year,y=mean_temp))  + 
  geom_point(position=pd, size=3.5, shape=16, color="#2c7fb8") + # Create line with series and specify its thickness
  geom_errorbar(aes(ymin=mean_temp-sd_temp, ymax=mean_temp+sd_temp), colour="black", width=.3, position=pd) +
  geom_smooth(method=lm, se=FALSE, color="black", linetype=1)+
  coord_cartesian(ylim=c(0,16),xlim=c(1984,2016))+
  scale_y_continuous(name = expression("Summer"~"T"["water "] (degree*C)),breaks=seq(0, 20, 2))+ 
  scale_x_continuous(name = "Year", breaks=seq(1984, 2016, 6))+
  # labs(x="Year",y="Temp", title="The Loch lake surface")+
  # geom_text(size=6, aes(x = 1988, y = 16,
  #                       label = "r^2 == 0.14"), parse = TRUE) +
  # geom_text(size=8,aes(x = 1990, y = 0.5,
  #                      label = "p = 0.033")) +
  geom_text(size=8,aes(x = 1993, y = 2, 
                       label = "y = 0.060x - 110.45")) +
  theme(
        axis.title.x=element_blank())
temp_JJA_means
# ggsave("figureS1_meanjulyh2o_v1.png", width=10, height=8,units="in")


temps_stacked <- ggarrange(temp_july_means,temp_JJA_means, 
                               ncol = 1, nrow = 2, align="v",
                               labels = c("A", "B"),
                               font.label = list(size = 30, face="bold"),
                               widths = c(2,2), heights = c(1,1))
# ggsave("figureS1_JJA_July.png", width=8, height=12,units="in")

```

####Loch wx station data
```{r}
####Loch weather station data
wx_raw<-read.csv("data/raw/LVWS_masterdata_temp_and_precip_180328.csv", stringsAsFactors = FALSE)
wx_long <- wx_raw %>%
  select(-Station) %>%
  gather(variable, temp, -Date) %>%
  dplyr::rename(date = Date) %>%
  mutate(date=mdy(date),
         month=month(date),
         DOY=yday(date),
         year=year(date)) 
str(wx_long)


wx_long <- wx_long%>%
  mutate(season = 
           ifelse(month %in% c(12, 1, 2), "winter",
                  ifelse(month %in% c(3, 4, 5), "spring",
                         ifelse(month %in% c(6, 7, 8), "summer",
                                ifelse(month %in% c(9, 10, 11), "fall", "ERROR")))))

#Order the months
wx_long$month <- factor(wx_long$month, levels=c('1','2','3',
                                                '4','5','6','7','8',
                                                '9','10','11','12'))
#Order seasons
wx_long$season <- factor(wx_long$season, levels=c('winter','spring',
                                                  'summer','fall'))

wx_long$variable <- factor(wx_long$variable)

wx_seasonal_summ_2M <- wx_long %>%
  filter(variable =="Tave2M")%>%
  filter(!is.na(temp))%>%
  mutate(
    month=as.factor(month))%>%
  group_by(year,season)%>%
  summarize(temp.mean=mean(temp),
            temp.sd=sd(temp),
            n=n()) 

wx_seasonal_summ_2M_summer <- wx_long %>%
  filter(season == "summer") %>%
  filter(variable =="Tave2M")%>%
  filter(year > "1984")

mod_JJAtemps_wx=lm(temp~as.numeric(year), data=wx_seasonal_summ_2M_summer)
summary(mod_JJAtemps_wx)

wx_seasonal_summ_2M_plot <- wx_seasonal_summ_2M %>%
  filter(season == "summer") %>%
  filter(year > "1984") %>%
  ggplot(aes(x=year, y=temp.mean))+
  geom_point(position=pd, size=3.5, shape=16, color="#2ca25f") + # Create line with series and specify its thickness
  # geom_point(position=pd, size=2.5, alpha=0.7, shape=16) + # Create line with series and specify its thickness
  geom_errorbar(aes(ymin=temp.mean-temp.sd, ymax=temp.mean+temp.sd), colour="black", width=.3, position=pd)+
  geom_smooth(method=lm, se=FALSE, color="black", linetype=1)+
  scale_x_continuous(breaks=seq(1984,2016,6))+
scale_y_continuous(name = expression("Summer"~"T"["air "](degree*C),breaks=seq(0,16,2)))+ 
  coord_cartesian(ylim=c(0,16),
                  xlim=c(1984,2016))+
  # facet_wrap(~month,nrow=4,ncol=3, scales="free")+
  # labs(title="LVWS weather station")+
  theme(legend.position="none",
        axis.title.x = element_blank()) +
  geom_text(size=8,aes(x = 1992, y = 2, 
                       label = "y = 0.021x - 30.44"))
wx_seasonal_summ_2M_plot


temps_waterair_stacked <- ggarrange(wx_seasonal_summ_2M_plot,temp_JJA_means, 
                           ncol = 1, nrow = 2, align="v",
                           labels = c("A", "B"),
                           font.label = list(size = 30, face="bold"),
                           widths = c(2,2), heights = c(1,1))
# ggsave("figures/MS/figure7_JJA_air_and_water.png", width=8, height=14,units="in")



##Fig for defense



temps_waterair_stacked2 <- ggarrange(wx_seasonal_summ_2M_plot,temp_JJA_means, 
                           ncol = 2, nrow = 1, align="v",
                           labels = c("A", "B"),
                           font.label = list(size = 30, face="bold"),
                           widths = c(2,2), heights = c(1,1))
ggsave("figures/MS/paleo_airwatertemp_horizonal_resubmission.png", width=16, height=8,units="in")


temps_waterair_stacked2 <- ggarrange(wx_seasonal_summ_2M_plot,temp_JJA_means, 
                           ncol = 1, nrow = 2, align="v",
                           labels = c("A", "B"),
                           font.label = list(size = 30, face="bold"),
                           widths = c(2,2), heights = c(1,1))
ggsave("figures/MS/paleo_airwatertemp_vertical_resubmission.png", width=8, height=14,units="in")



```

####PRISM data
```{r}

PRISM <- read.csv("data/raw/PRISM_trim.csv")
head(PRISM)
str(PRISM)

####DATE CONVERSION###
library(lubridate) #To tell R that my dates are dates
# str(S.1983.LO$DATE)
PRISM$DATE <- ymd(as.character(PRISM$DATE))

library(tidyverse)
#Create a new column that has just the year
PRISM <- PRISM %>%
  mutate(Year = year(DATE),
         Month = month(DATE))

PRISM_TEMP_JJA_SUM <- PRISM %>%
  select(DATE, Year, Month, tmean_C) %>%
  filter(Month %in% c("6","7","8")) %>%
  group_by(Year) %>%
  summarize(mean_temp=mean(tmean_C),
            sd_temp=sd(tmean_C))

mod_PRISM_JJA=lm(mean_temp~Year, data=PRISM_TEMP_JJA_SUM)
summary(mod_PRISM_JJA)

library(tidyquant)
pd <- position_dodge(0.1) # move them .05 to the left and right
PRISM_temp_JJA_means <- PRISM_TEMP_JJA_SUM %>%
  filter(Year >= 1900) %>%
  ggplot(aes(x=Year,y=mean_temp))  + 
    geom_smooth(method=lm, se=FALSE, color="black", size=3)+
  geom_point(position=pd, size=3.5, shape=16, color="#8856a7") + # Create line with series and specify its thickness
  # geom_errorbar(aes(ymin=mean_temp-sd_temp, ymax=mean_temp+sd_temp), colour="black", width=.3, position=pd) +
  coord_cartesian(ylim=c(0,16),xlim=c(1900,2020))+
  scale_y_continuous(name = expression("Summer"~"T"["air"],breaks=seq(0, 20, 2)))+ 
  scale_x_continuous(name = "Year", breaks=seq(1900, 2020, 20))+
  labs(x="Year",y="Temp", title="PRISM record")+
  # geom_text(size=6, aes(x = 1988, y = 16, 
  #                       label = "r^2 == 0.14"), parse = TRUE) + 
  # geom_text(size=6,aes(x = 1988, y = 15, 
  #                      label = "p = 0.033")) +
  geom_text(size=8,aes(x = 1915, y = 2, 
                       label = "y = 0.011x - 13.2")) +
  theme(axis.title.x=element_blank())
PRISM_temp_JJA_means

```

```{r}
#Segmented regression

library(segmented)

# Fit segmented model
segfit_PRISM <- segmented(mod_PRISM_JJA, seg.Z = ~ Year, psi=1980)
#seg.Z=~X1 indicates the contious segment variable being tested

#get the breakpoints
segfit_PRISM$psi #Est. = 1985.35
PRISM_breakpoint <- round(as.vector(segfit_PRISM$psi[, "Est." ])) 
PRISM_breakpoint #Rounded
plot(segfit_PRISM)
points(mean_temp~Year, data=PRISM_TEMP_JJA_SUM)

slope(segfit_PRISM) # get the slopes
intercept(segfit_PRISM)
my.lines <- segfit_PRISM$psi[, 2]

PRISM.confit <- confint(segfit_PRISM) # get confidence intervals
bp_PRISM <- PRISM.confit$Year[,1] #breakpoint 
bp_PRISM
CI.l_PRISM <- PRISM.confit$Year[,2] #confidence interval lower
CI.l_PRISM
CI.u_PRISM <- PRISM.confit$Year[,3] #confidence interval upper
CI.u_PRISM

# Make statistically defensible statements about trends 
davies.test(mod_PRISM_JJA, seg.Z=~Year, k=10) #k=10 is default 

# get the fitted data
my.fitted <- fitted(segfit_PRISM)
my.model <- data.frame(Year = PRISM_TEMP_JJA_SUM$Year, Temp = my.fitted)

# plot the fitted model
ggplot(my.model, aes(x = Year, y = Temp)) + geom_line()

# add the fitted data to the exisiting plot
PRISM_temp_JJA_means2 <- PRISM_temp_JJA_means +
  geom_line(data = my.model, aes(x = Year, y = Temp),
            colour = "black", size=1.0, linetype=2)+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank())
PRISM_temp_JJA_means2


### Separate line for each period identified by segmented regression 
PRISM_temp_JJA_means_segmented <- ggplot(data = my.model, aes(x = Year, y = Temp))  + 
    # geom_smooth(method=lm, se=FALSE, color="black", size=3)+
  geom_point(data=PRISM_TEMP_JJA_SUM, aes(x=Year, y=mean_temp),
             position=pd, size=2, shape=21, color="black",fill="grey50" ) + # Create line with series and specify its thickness
    geom_line(data = my.model, aes(x = Year, y = Temp),
            colour = "black", size=1, linetype=1)+
  # geom_errorbar(aes(ymin=mean_temp-sd_temp, ymax=mean_temp+sd_temp), colour="black", width=.3, position=pd) +
  coord_cartesian(ylim=c(6,12),xlim=c(1900,2020))+
  scale_y_continuous(name = expression("Summer"~"T"["air"],breaks=seq(6, 12, 2)))+ 
  scale_x_continuous(name = "Year", breaks=seq(1900, 2020, 20))+
  labs(x="Year",y="Temp")+
  # geom_text(size=6, aes(x = 1988, y = 16, 
  #                       label = "r^2 == 0.14"), parse = TRUE) + 
  # geom_text(size=6,aes(x = 1988, y = 15, 
  #                      label = "p = 0.033")) +
    geom_text(size=4,aes(x = 1919, y = 11.5,
                       label = "pre-1985: N.S.")) +
  geom_text(size=4,aes(x = 1938, y = 11,
                       label = "post-1985: y = 0.06x - 119.1")) +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.title.y=element_text(face="plain"))
PRISM_temp_JJA_means_segmented


PRISM_TEMP_JJA_SUM_pre1985 <- PRISM_TEMP_JJA_SUM %>%
  filter(Year <= 1985)

PRISM_TEMP_JJA_SUM_post1985 <- PRISM_TEMP_JJA_SUM %>%
  filter(Year > 1985)

mod1 <- lm(mean_temp~Year, data=PRISM_TEMP_JJA_SUM_pre1985)
summary(mod1)
mod2 <- lm(mean_temp~Year, data=PRISM_TEMP_JJA_SUM_post1985)
summary(mod2)
```

#####All 3 together
```{r}


all_temps_arrangement2 <- ggarrange(PRISM_temp_JJA_means,                                                 # First row with scatter plot
                          ggarrange(wx_seasonal_summ_2M_plot, temp_JJA_means, ncol = 2, 
                                    font.label = list(size = 30, face="bold"), labels = c("B", "C")), # Second row with box and dot plots
                          nrow = 2, 
                          labels = "A",
                          font.label = list(size = 30, face="bold"))                                        # Labels of the scatter plot
annotate_figure(all_temps_arrangement2,
                left = text_grob( expression("Mean JJA temperature " ( degree*C)), color = "black", face="bold", size=32, rot = 90),
                bottom = text_grob("Year", color = "black", size=32)
)

ggsave("figures/MS/Figure7_withPRISM_B.png", width=14, height=10,units="in")
```


####Literature data
```{r}

Ndep <- read.csv("data/raw/anthroN_tgNyr_battyeetal2017.csv")
head(Ndep)
str(Ndep)

colnames(Ndep)<- c("year","dep_tgNyr") #Add columns
trunc(Ndep$year) #Rounds down to the nearest whole number


library(tidyquant)
pd <- position_dodge(0.1) # move them .05 to the left and right
globalNdep <- ggplot(Ndep,aes(x=year,y=dep_tgNyr))  + 
  annotate("rect", xmin=1940, xmax=1960, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
  geom_line(size=1)+
  coord_cartesian(ylim=c(0,200),xlim=c(1900,2020))+
  scale_y_continuous(name = expression(N~emissions~(Tg~N~y^-1)), breaks=seq(0, 200, 50)) +
  scale_x_continuous(name = "Year", breaks=seq(1900, 2020, 20)) +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.title.y=element_text(face="plain"))
  # labs(title="Battye et al., 2017 Earth's Future")
globalNdep


Pdep <- read.csv("data/raw/Neff2008_data.csv")
head(Pdep)
str(Pdep)

colnames(Pdep)<- c("Pdep_gPm2y","years_BP") #Add columns
Pdep <- Pdep %>%
  mutate(year = 2008 - years_BP)
trunc(Pdep$year) #Rounds down to the nearest whole number


localPdep <- Pdep %>%
  filter(year >= 1900) %>%
  ggplot(aes(x=year,y=Pdep_gPm2y))  + 
    annotate("rect", xmin=1975, xmax=1985, ymin=-Inf, ymax=Inf, alpha=0.3, fill="grey50") +
    geom_line(size=1)+
  geom_point( size=2, shape=21, color="black",fill="grey50")+
  coord_cartesian(ylim=c(0.2,0.5),xlim=c(1900,2020))+
  scale_y_continuous(name = expression(P~accumulation~(g~m^-2~y^-1)), breaks=seq(0.2, 0.5, 0.1)) +
  scale_x_continuous(name = "Year", breaks=seq(1900, 2020, 20))
  # labs(title="Neff et al., 2008 Nature Geoscience")
localPdep

```

#####All 3 together
```{r}


ggarrange(PRISM_temp_JJA_means_segmented,globalNdep, localPdep, 
          labels = c("A", "B","C"),
          font.label = list(size = 12, face="bold"),
          align="v",
          ncol = 1, nrow = 3,
          widths = c(2,2,2), heights = c(1,1,1.2))

# ggsave("figures/MS/figure7_tempNP_trends_resubmission_FINAL_600dpi.png", width=8, height=19.2,units="in", dpi=600)
ggsave("figures/MS/figure7_tempNP_trends_resubmission_FINAL_600dpi_small.png", width=4, height=8,units="in", dpi=600)

```





        
        
### Figure 5 - All pigments
```{r}
lutein_plot2 <- lutein_plot +
    theme(legend.position = "none",
        plot.margin=unit(c(0.5,0.5,0.5,1), "lines"),
        axis.ticks.length = unit(3, "pt"))

  pheoa_plot<-pheoa_plot+
  theme(legend.position = "none",
        plot.margin=unit(c(0.5,0.5,0.5,1), "lines"),
        axis.ticks.length = unit(3, "pt"))

cantha_plot2 <- cantha_plot +
  theme(axis.title.x=element_text(size=12),
        axis.text.x=element_text(size=12, angle = 45, vjust=0.55))


allo_plot2 <- allo_plot +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_text(size=12, angle = 45, vjust=0.55))


myxo_plot2 <- myxo_plot +
  theme(axis.text.x=element_text(size=12, angle = 45, vjust=0.55))



AtoD <- ggarrange(pheoa_plot,
                  lutein_plot2,diatox_plot,cantha_plot2,
                  labels = c("A", "B","C","D"),
                  font.label = list(size = 12, face="bold"),
                  ncol = 2, nrow = 2, align="hv",
                  common.legend = TRUE, legend = "none")
annotate_figure(AtoD,
                left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)),
                                 color = "black", face="bold", size=12, rot = 90)
                # left = text_grob("Pigment concentration (nmol/g organic carbon)", color = "black", face="bold", size=32, rot = 90)
)
# ggsave("figures/MS/figure2_all_pigments_procB_FINAL_600dpi.jpg", width=18, height=18,units="in", dpi=600)
ggsave("figures/USGS_RandD_PaleoFigure_OleksyetalProcB2020", width=9, height=9,units="in", dpi=600)


# 
# 
#Total in lake production
# bcar_plot2 <- bcar_plot +
#   theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55))
# 
# 
# totalprod<-ggarrange(pheoa_plot, bcar_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# annotate_figure(totalprod,
#                 left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)), color = "black", face="bold", size=32, rot = 90))
# 
# 
# ggsave("figures/defense/paleo_totalprod.png", width=12, height=18,units="in")
# 
# 
# 
# # Total chlorophytes
# lutein_plot2 <- lutein_plot +
#    labs(y="", x="", title=c(expression(paste("Pheophytin ",italic("b")))),
#        subtitle="Green algae")+
#   theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55))
# 
# pheob_plot2 <- pheob_plot +
#   labs(y="", x="", title=c(expression(paste("Lutein & Zeaxanthin"))),
#        subtitle="Green algae and cyanobacteria")
# greens<- ggarrange(pheob_plot2, lutein_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# annotate_figure(greens,
#                 left = text_grob(expression(Pigment~concentration~(nmol*~g^-1~organic~carbon)), color = "black", face="bold", size=32, rot = 90))
# 
# ggsave("figures/defense/paleo_chlorophytes.png", width=12, height=18,units="in")
# 
# #Diatom action!!
# diatox_plot2 <- diatox_plot +
#   theme(axis.text.x=element_blank())+
#   labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# 
# 
# diatox_plot3 <- diatox_plot +
#   theme(axis.text.x=element_blank())+
#   labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# diatox_plot3
# # ggsave("figures/defense/paleo_diatox_alone.png", width=12, height=12,units="in")
# 
# 
# perc_diatox_plot2 <- perc_diatox_plot +
#     theme(axis.text.x=element_text(size=24, angle = 45, vjust=0.55)) 
# 
# 
# ggarrange(diatox_plot2, perc_diatox_plot2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# 
# ggsave("figures/defense/paleo_diatoms.png", width=12, height=18,units="in")
# 
# 
# diatox_plot4 <- diatox_plot + 
#     labs(y=expression(bold(Pigment~conc.~(nmol*~g^-1~OC))))
# PB2 <- diatom_full %>%
#   ggplot(aes(x=age_sky,y=PB, label=INSTAAR_accession_num))+
#   geom_point(size=4,color="grey50") +
#   labs(y="Ratio", x="", title="Planktonic:Benthic")+
#   geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE, color="black", linetype=2) +
#   # geom_smooth(aes(x=age_sky,y=PB), method="gam",se=FALSE, color="black", linetype=2)+
#   scale_y_continuous(breaks=seq(0,1.25, 0.25))+
#   scale_x_continuous(breaks=seq(1600, 2000, 50))+
#   coord_cartesian(ylim=c(0,1.25),
#                   xlim=c(1600,2010))+
#   scale_fill_manual(
#     name="\n",
#     breaks=c("SkyPond","TheLoch"),
#     labels=c("Sky Pond","The Loch"),
#     values = c(0, 16))+
#   theme(legend.position="bottom", legend.text = element_text(size=12),
#         axis.text.x=element_text(size=24, angle = 45, vjust=0.55))+
#   guides(shape = guide_legend(override.aes = list(size=10)),
#          color = guide_legend(override.aes = list(linetype = 0)))
#   
# 
# 
# 
# ggarrange(diatox_plot4, PB2,
#           labels = c("A", "B"),
#           font.label = list(size = 30, face="bold"),
#           align="v",
#           ncol = 1, nrow = 2,
#           common.legend = TRUE,
#           legend="bottom",
#           widths = c(2,2), heights = c(1,1.1))
# 
# ggsave("figures/defense/paleo_diatox_and_PB.png", width=12, height=18,units="in")
# 



```
